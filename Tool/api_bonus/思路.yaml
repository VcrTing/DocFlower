
概要:
  1. 所有对于奖励的计算，都是基于树形结构 Object
  2. 计算过程尽量采用 Promise 提速
  3. 代码中，尽量有对应于每一位树形图用户的 钩子函数，即 hook function for every user
  4. 为了提升可变性，内部的一些静态设置，尽量定义在 config 文件中
  5. 全架构采取关于时间点的 循环操作制 # 例如：每月28日 23:00执行总计算
  6. 尽量提高 function 的复用性
  7. 尽量对于计算步骤的数量，有一个很好的监控
  
循环操作制:
  循环根基: 基于时间 # 暂定每月 28 日 23:00
  执行相关: 使用定时任务
  
  执行流程文字简介:
    定时任务判断当前时间 -> 若为 28 日 23:00 则执行封装方法 -> 方法计算出所有奖励相关的数据 -> 将奖励信息储存到数据库 

  
奖励相关:

  首购推荐:
    结构: Enroller
    文字描述:
      0代往下3层，记录每一名成员是否是新人，买了多少东西，每一层都有对应的奖金比率用于结算，最终把往下3层结算的奖金相加
    涉及参数:
      1. # 是否新人
      2. # 奖金比率

  活跃分店:
    结构: Sponsor
    文字描述:
      0代往下2层，记录，是否买了东西，如果买了，则加入已买，第一层超过3人，3人中每人层下又有3人，总记12人，若均买超过100pv，则0代 +130 奖励
    涉及参数:
      1. # 3人 判断值
      2. # 100pv 超越值
      3. # 130 奖金值


  团队销售:
    结构: Sponsor Enroller 均使用，enroller 结构判断子成员pv, 自成员数量 条件。sponsor 判断 自身pv 以及 自身pv + 子成员pv，
    文字描述:
      判断自身是否满足100ov，如果满足，则判断子成员pv，再判断自成员合格数量，再判断总pv，最后得出 Vip 类型，最后根据vip 类型使用上层压缩计算0代奖金
    涉及参数:
      1. # 100pv 超越值
      2. # 本人pv
      3. # 子成员总pv
      4. # 合格子成员数量
      5. # vip type
      6. # 根据 vip type 获取 ratios

    中转操作:
      由于并非单一结构进行数据判断，则需要提取 sponsor enroller 结构后，判定完条件后，使用后台装载数据，进行数据中转操作
      之后再根据储存在后台的 数据条件，判定 vip type 以及 最终团队销售奖励。

结构相关:
  结构模型: sponsor 模型，enroller 模型

  摘要:
    1. 两模型互不干扰，一名成员在 sponsor模型内 属于 A成员，很有可能在 enroller模型 内却不属于 A成员
    2. 模型数据由单一数组 通过递归计算 转化为 树形结构

    3. 通过索引值去判断成员是否处于0代的 sponsor 树形结构中 或是 enroller 树形结构中
    4. 除了无上司成员，每个人既不是第0代，又可以是第0代。
      
轮回相关:
  轮回限定: 每一个月是一个轮回 # 轮回判定时间是 每月 28日 23:00

  限定来源:
    http://www.ntpjs.org

  时间来源的好处:
    1. 当产生 系统 Linux 宕机、更换服务器、更换时区、更换运行系统时，避免时间错乱的情况
    2. 使用固定的、安全的、统一的 时间来源建立的 轮回标识，可以更好根据时间来管理数据

  轮回标识:
    给予每一项数据，一个轮回标识，代表这项数据，处于该轮回中
    当你想知道某一时间段的数据时，仅需要根据该轮回标识就行 filter 即可

  轮回标识新增的概要: # 在什么时候应该新增轮回标识?
    1. 当所有人的该月的结算结束后，新增轮回标识，
    2. 在新轮回标识 新增未结束 之前，所有人不可进行数据同步
    3. 新轮回标识新增结束后，所有人同步的数据，均加入到新轮回标识中。

  轮回标识的更换:
    1. 当产生 上月购买，该月退款 的情况时，标识未变，无须更改
    2. 当该月月底机器宕机，未来得及新增标识，所有的数据 ，在机器修复之前，均使用 上月的标识，修复之后，当日晚 23:00，进行总结算。

  
API:
  总结算:
    步骤:
      0 # 执行 开始前的方法。
      1 # 根据 sponsor 索引，拉取 sponsor 用户列表，
      2 # 再根据 enroller 索引，拉取 enroller 用户列表

      3 # 递归 将 各模型 用户列表 转化为 树形结构
      4 # 树形结构转化过程中，计算每人的pv

      5 # 使用一个中转列表，进入 sponsor 结构递归，获取 sponsor 结构应该获取的数据
      6 # 继续使用该中转列表，进入 enroller 结构，获取 enroller 结构应该获取的数据 

      7 # 携带 中转列表 以及 某一 树形结构，进入中央控制 递归
      8 # 计算 首购推荐、活跃分店、团队销售，结果录入中转列表

      9 # 递归计算过程中，应当执行钩子函数
      10 # 最终得到的 中转列表，执行 同步开始前 的方法

      11 # 对中转列表进行同步
      12 # 执行 最后 的方法

    开始前的方法:
      判断今日是否是结算日，是则：关闭用户任何的同步操作、关闭系统任何的同步操作